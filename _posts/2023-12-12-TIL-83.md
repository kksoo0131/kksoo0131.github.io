---
layout: post
title:  "팀 프로젝트 예상 질문 답변"
date:   2023-12-12
excerpt: "내일배움캠프 83번째 TIL "
tag:
- TIL
- 내일배움캠프
- 스파르타
comments: true
---

![nbcbanner](/assets/img/TILbanner.png)

1. 사용해본 패턴 중 기억나는것 하나를 설명해주세요.

2. 제네릭에 대해 설명해주세요.

3. 느슨한 결합이 가지는 결과에 대해 설명해 주실 수 있으신가요??

4. Adressable 시스템을 사용한 이유가 무엇인가요?? 비동기에 대해서도 설명해주세요.

5. 진행한 최적화 방법에 대해 설명해주세요.

6. 게임이 복합 장르인데다 덱 빌딩요소까지 섞여있다보니 많은 버그가 필연적으로 발생했을 것 같은데, 어떤 버그가 가장 기억에 남고 어떻게 해결 했는지 말씀해주세요.


<br/>
<br/>


## 사용해본 패턴 중 기억나는것 하나를 설명해주세요. : 전략 패턴

카드의 효과를 구현할 때 전략패턴을 참고해서 만들었습니다.

게임의 특성상 여러가지 카드가 추가될 것이고 카드를 사용할때 몬스터의 데이터를 

하나 또는 그이상 수정하게 될 것이라고 생각했고 특정 데이터를 수정하는 효과(전략)들을 

미리 ScriptableObject로 정의해두고 어떤 카드의 데이터 ScriptableObject를 만들때 

사용하고 싶은 효과들을 선택할 수 있도록 했습니다.

예를 들어 카드A를 만들때 만약 몬스터의 스트레스를 조절하는 효과를 주고싶다면 해당 

전략을 카드 데이터 SO에 추가하면됩니다.

그리고 카드 B는 스트레스와 배고픔 모두 조절하고 싶다면 두가지 전략 모두를 카드 데이터 

SO에 추가 하면 됩니다.

이후 만약 카드 B의 기능이 변경되어서 배고픔 만을 조절해야 된다면 카드 데이터 SO에서 

스트레스 관련 SO만 제거하면 됩니다.

전략패턴을 사용하면 이런식으로 변경과 확장에 유연하게 대처할 수 있다는 장점이 있습니다.

<br/>
<br/>

## 제네릭에 대해 설명해주세요.

ObjectManager에서 Object를 꺼내오거나 다시 Pool에넣을때 의 메서드들을 여러가지 

타입에 대응이 가능하도록 제네릭 메서드로 만들었습니다.


그래서 여러 다른 GameObject를 풀에서 꺼낼때 GameObject가 아닌 T타입으로 컴포넌트를 

가져와 오브젝트를 사용하는 쪽에서 GetComponent를 따로 해줘야 할 필요없이 사용할 수 

있었고 


이렇게 제네릭을 사용함으로 T타입을 반환하지 못하는 경우 컴파일 시점에서 알 수 있기 

때문에 타입 안정성을 향상 시킬 수 있었습니다.

<br/>
<br/>

## 느슨한 결합이 가지는 결과에 대해 설명해 주실 수 있으신가요??

느슨한 결합을 통해서 각 컴포넌트의 독립성이 증가하고 변경사항이 다른 컴포넌트에 미치는 영향이 줄어들어 유지보수, 확장성, 재사용 측면에서 이점을 얻었습니다.

처음에 MVC 패턴을 적용하지 않았을때는 강한 결합으로 인해서 버그를 찾는데 어려움을 겪었습니다. 

예를 들어 MVC 패턴을 적용하지 않았을 때는 Cage 오브젝트는 Cage에 데이터에 대한 정보와 데이터를 수정하는 Cage 클래스와 CageInfo, MonsterInfo, CageCard, CageItem 등의 각각의 UI들을 변경하는 컴포넌트를 가지고 있었습니다

그리고 예를 들어 Cage에 아이템을 추가해 온도 정보가 변한다면 CageItem -> Cage -> CageInfo의 순서로 접근을 하게 됬고 그러기 위해서는 Cage 클래스와 각각의 기능 클래스들이 서로 참조하도록 강하게 결합되어 있었습니다.

그렇기 때문에 버그가 발생했을때 기능을 수정하면 연결된 기능들을 전부 확인해야 되고
결국은 수정과 테스트를 여러번 거쳐서 새로운 버그가 발생하지 않도록 작업을 진행해야 했습니다.  

그런 과정을 통해 결합도가 강하여 변경이 어렵고, 유지 관리가 어렵다라는 생각이 들었고
MVC 패턴을 적용하며 느슨한 결합을 고려하게 되었습니다.

Cage(Model) 그리고 각각의 기능들을 Controller - View로 나눈뒤 CageMainController를 통해서 접근했습니다.
각각의 controller는 model,view를 알고 있습니다.
하지만 model과 view는 다른것들을 알 필요가 없고
controller에서 호출을 받아 동작하게 되었습니다.

MVC패턴으로 구조를 개선하고나서 책임을 가진 controller, view를 수정하는것으로 버그를 해결할 가능성이 높아져 변경, 유지 관리에서 이점이 생겼고 비슷한 기능을 구현할 때 controller를 재사용할 수 있는 가능성이 높아져 효율성이 증가했습니다.

<br/>
<br/>

## Adressable 시스템을 사용한 이유가 무엇인가요?? 비동기에 대해서도 설명해주세요

Adressable 시스템을 사용해보게 된 이유에는 편의성, 비동기로딩,로드 상태 추적, 메모리 관리, 원격 관리등에서의 이점에서 있습니다.

편의성 면에서 Resources는 모든 리소스들이 폴더의 하위에 포함되어야 하지만 Addressables는 주소(Addressable name)을 통해 리소스들을 관리하기 때문에 한번 연결하게 되면 리소스의 위치나 이름이 바뀌어도 주소를 통해 접근할 수 있다는 장점이 있습니다.

비동기 로딩 측면에서 Addressable은 비동기 로딩이 권장되는데 Addressable은 비동기 로딩 기능은 게임의 메인스레드를 방해하지 않고 백그라운드로 리소스를 로드해 게임이 끊김 없이 진행되도록 할 수 있다는 장점이 있습니다.


또 Addressable은 Handle을 통해서 리소스가 로드 작업을 추적하고 상태를 파악할 수있습니다.

이를 통해서 중복 로드를 방지할 수 있습니다.


또 프로젝트에서는 활용하지는 못했지만

메모리 관리 측면에서 Resources는 언로드 방법이 사용하지 않고 있는 모든 리소스를 언로드 하는 방법밖에 없지만 Addressable은 각자의 리소스에 대해서 언로드를 제어할 수 있다는 장점이 있고

리소스를 원격서버로 관리할 수 있고 그렇기 때문에 ScriptableObject의 단점인 빌드를 해야한다는 점을 해소할 수 있다는 장점도 있습니다.

### Addressable을 어떤 식으로 사용하고 있는지 설명해주세요.

Addressable Groups에 Addressable로 사용하기 위한 리소스들을 등록해주고

id관리하는 리소스들의 주소를 호출하기 쉽도록 Type_ID 로 맞춰주었습니다.

그리고 ResourceManager에서 AssetReference나 string key (주소)를 통해서 리소스의 로드를 호출하면 Dictionary<string, AsyncOperationHandle> 을 가지는 handleDic에

해당 리소스의 핸들이 있는지 확인하고 리소스를 비동기로 로드하거나 이미 로드된 리소스를 반환하도록 해서 로드 중이거나 로드 완료된 리소스를 중복 로드하지 않도록 하고 있습니다.
<br/>
<br/>

## 진행한 최적화 방법에 대해 설명해주세요.

캐치씬과 메인씬을 반복해서 이동하게 되는 프로젝트의 특성상 오브젝트의 파괴와 생성이 불필요하게 많이 일어날 것이라고 생각했습니다.

그래서 오브젝트 풀링을 사용하여 오브젝트를 재사용하여 오브젝트의 생성과 파괴를 줄였습니다.

<br/>
<br/>

## 게임이 복합 장르인데다 덱 빌딩요소까지 섞여있다보니 많은 버그가 필연적으로 발생했을 것 같은데, 어떤 버그가 가장 기억에 남고 어떻게 해결 했는지 말씀해주세요.

게임을 저장하기 위해서는 각자 파트의 여러가지 데이터들을 직렬화하여 JSON을 저장을 해야 했는데 처음 만들 때 이 부분을 깊게 고려하지 않았고 직렬화가 되지 않는 데이터들을 직접 참조하고 있었습니다. 그래서 세이브&로드를 부분을 적용하기 시작할때 데이터들을 저장할 수 없었고 이를  해결하기 위해서 Cage, Card 부분들의 구조를 MVC 패턴을 고려하여 개선하고 이미지 리소스들을 가지고 있던 CardSO를 참조하는 각각의 부분들에서 CardSO의 id값만을 저장하도록 변경했습니다.

<br/>
<br/>

![nbcthumbnail](/assets/img/thumbnail-image.png)